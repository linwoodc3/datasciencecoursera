answers <- c(answers,cor(na.omit(dat[which(dat[,"ID"]==i),])["sulfate"],na.omit(dat[which(dat[,"ID"]==i),])["nitrate"]))
else
return(answers)
}
answers
threshold <- 150
holder <- c["V1"][which(c$cases>threshold),"V1"]
answers <- numeric(0)
for (i in holder){
if (length(holder)>1)
answers <- c(answers,cor(na.omit(dat[which(dat[,"ID"]==i),])["sulfate"],na.omit(dat[which(dat[,"ID"]==i),])["nitrate"]))
else
return(answers)
}
answers
summary(answers)
source("corr.R")
corr("specdata",150)
submit()
submit()
submit()
devtools::install_github("hadley/lineprof")
View(complete)
View(complete)
str(lapply)
?lapply
mean(x)
mean(w)
traceback
traceback()
lm(w-z)
traceback()
debug(lm)
lm(w-z)
library(datasets)
data("iris")
?iris
iris.summary()
iris
colnames(iris)
iris[['Sepal.Length']]
iris['Sepal.Length']
iris['Sepal.Length'][which(iris$Species==virginica),'Sepal.Length']
iris['Sepal.Length'][which(iris$Species=virginica),'Sepal.Length']
iris['Sepal.Length'][iris['Sepal.Length']=='virginica'
iris['Sepal.Length'][iris['Sepal.Length']==virginica
iris['Sepal.Length'][iris['Species']==virginica]
iris['Species']==virginica
iris['Species']=='virginica'
iris['Sepal.Length'][iris['Species']=='virginica']
mean(iris['Sepal.Length'][iris['Species']=='virginica'])
iris[,1:4]
apply(iris[,1:4],mean)
apply(iris[,1:4],1,mean)
apply(iris[,1:4],2,mean)
colMeans(iris)
apply(iris,2,mean)
apply(iris[,1:4],2,mean)
library(datasets)
data("mtcars")
?mtcars
mtcars
colnames(mtcars)
?tapply
sapply(mtcars,cyl,mean)
sapply(mtcars,cyl,mean)
sapply(split(mtcars$mpg,mtcars$cyl),mean)
tapply(mtcars$cyl,mtcars$mpg,mean)
mtcars['cyl']
mtcars['cyl']&mtcars['mpg']
mtcars['cyl','mpg']
mtcars[['cyl','mpg']]
mtcars['cyl'&'mpg']
mtcars[,c("mpg","cyl")]
apply(mtcars[,"mpg"][which(mtcars$cyl==6,"cyl")])
apply(mtcars[,"mpg"][which(mtcars$cyl==6,"cyl")],mean)
apply(mtcars[,"mpg"],2,mean)
apply(mtcars[,"mpg"],1,mean)
apply(mtcars[,"mpg"],2,mean)
mtcars["cyl"]==6
mtcars[mtcars["cyl"]==6]
mtcars[,'cyl'][mtcars["cyl"]==6]]
mtcars[,'cyl']mtcars["cyl"]==6]
mtcars["cyl"]==6
mtcars[,'cyl']mtcars["cyl"]==6
mtcars[,'cyl'][mtcars["cyl"]==6]
mtcars[,'mpg'][mtcars["cyl"]==6]
mean(mtcars[,'mpg'][mtcars["cyl"]==6])
sapply(split(mtcars$mpg,mtcars$cyl),mean)
debug(ls)
ls
n
ls
ls
q
end
exit()
ls
debug(ls)
ls
ls
ls
ls
nnnn
c
l=x
2+2
debug(ls)
Q
Q
q
View(submit)
ls
debug(ls)
degug
debug
Q
Q
ls
mtcars
mtcars
ls
ls
mtcars
sapply(split(mtcars$mpg,mtcars$cyl),mean)
b<-sapply(split(mtcars$mpg,mtcars$cyl),mean)
b[1]
b[1]-b[3]
mean(iris['Sepal.Length'][iris['Species']=='virginica'])
apply(iris,2,mean)
apply(iris[,1:4],2,mean)
d
ls
sapply(split(mtcars$mpg,mtcars$cyl),mean)
mtcars$hp
q
sapply
sapply(split(mtcars$hp),mean)
sapply(split(mtcars$hp==4,mtcars$hp==8),mean)
sapply(split(mtcars$hp,mtcars$cyl),mean)
b<-sapply(split(mtcars$hp,mtcars$cyl),mean)
abs(b[1]-b[3])
b[1]-b[3]
mean(iris['Sepal.Length'][iris['Species']=='virginica'])
apply(iris[,1:4],2,mean)
mean(89,72,94,69)
a= c(1,2,3)
a
a = [1,2;3,4;5,6]
matrix(3,2)
matrix(3,2,4)
matrix(randu,2,4)
matrix(rnorm,2,4)
rnorm
##function plusFunctions stores two functions:
## plustwo() : sums 2 to the given value
## plusthree() : sums 3 to the given value
plusFunctions <- function (){
plustwo <- function(y) {
x <- y + 2
return(x)
}
plusthree <- function(y) {
x <- y + 3
return(x)
}
#the following line stores the two functions:
list(plustwo = plustwo, plusthree = plusthree)
}
a <- plusFunctions()
a$plustwo(5)
ls
pwd
cwd
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
# The following function returns the inverse of the matrix. It first checks if
# the inverse has already been computed. If so, it gets the result and skips the
# computation. If not, it computes the inverse, sets the value in the cache via
# setinverse function.
# This function assumes that the matrix is always invertible.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data.")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
a <- makeCacheMatrix(m)
x = matrix(c(2,3,4,1,5,7),nrow=3,ncol=2)
x
## Put comments here that give an overall description of what your
## functions do
## This file has a pair of functions that cache the inverse of a matrix.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinverse(m)
inv
}
ls
source("cachematrix.R")
## Put comments here that give an overall description of what your
## functions do
## This file has a pair of functions that cache the inverse of a matrix.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinverse(m)
inv
}
makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
my_matrix$getinverse()
cacheSolve(my_matrix)
pwd
pwd
cwd
wd
gwd
cwd
source("ProgrammingAssignment2/cachematrix.R")
cacheSolve(my_matrix)
my_matrix$getinverse()
submit()
source("submit")
library(swirl)
swirl()
swirl()
5+7
x<- 5_7
x<- 5+7
x
y<- x-3
y
z<- c(1.1,9,3.14)
?c
z
c(z,555,z)
z*2+100
my_sqrt<-sqrt(z-1)
my_sqrt
my_div <- z/my_sqrt
my_div
C(1,2,3,4) + c(0,10)
c(1,2,3,4) + c(0,10)
c(1,2,3,4) + c(0,10,100)
c(1,2,3,4) + c(0,10,100)
z*2+1000
my_div
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript3.R")
source("submitscript3.R")
source("submitscript3.R")
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript3.R")
submit()
matrix(c(2, 4, 3, 1, 5, 7),nrow=3,ncol=2)
x <- matrix(c(2, 4, 3, 1, 5, 7),nrow=3,ncol=2)
makeCacheMatrix(x)
a <- makeCacheMatrix(x)
solve(x)
x <- matrix(c(2, 4, 3, 1, 5, 7,10,3,9),nrow=3,ncol=3)
solve(x)
a$setinverse(solve(x))
a$getinverse()
cacheSolve(x)
x
cacheSolve(x)
rm(y,z,cacheSolve(),makeCacheMatrix(),my_matrix,a,x)
rm x
?rm
rm(x)
rm(a)
rm(y)
rm(z,my_div,my_matrix)
rm(my_sqrt)
rm(plusFunctions())
View(makeCacheMatrix)
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y){
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(inverse) inv <<- inverse
getinv <- function() inv
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data,...)
x$setinv(inv)
inv
}
makeCacheMatrix(matrix(3,4;2,4))
makeCacheMatrix(matrix(3,5,3,4, nrow=2, ncol=2))
source("makeCacheMatrix.R")
ls
ls
pwd
cwd
pwd
ls
outcome <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
gewd
getwd()
outcome <- read.cs("./rprog-data-ProgAssignment3-data/outcome-of-care-measures.csv")
outcome <- read.csv("./rprog-data-ProgAssignment3-data/outcome-of-care-measures.csv", colClasses = best <- function(state, outcome) {
## Read outcome data
##outcome_name: "heart attack", "heart failure", "pneumonia"
## Check that state and outcome are valid
## Return hospital name in that state with lowest 30-day death
## rate
#read in the desired data
data <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
#check if the state and outcomes are valid
states <- data[ , 7]
outcomes <- c("heart attack", "heart failure", "pneumonia")
if ((state %in% states) == FALSE) {
stop(print("invalid state"))
}
else if ((outcome %in% outcomes) == FALSE) {
stop(print("invalid outcome"))
}
#get the subset of the data with the desired state
new_data <- subset(data, State == state)
#get the desired outcome column from the data file
if (outcome == "heart attack") {
outcome_column <- 11
}
else if (outcome == "heart failure") {
outcome_column <- 17
}
else {
outcome_column <- 23
}
#get rid of the NA's in the desired outcome column
required_columns <- as.numeric(new_data[,outcome_column])
bad <- is.na(required_columns)
desired_data <- new_data[!bad, ]
#find the hospitals in the rows with the minimum outcome value
columns_considered <- as.numeric(desired_data[, outcome_column])
desired_rows <- which(columns_considered == min(columns_considered))
desired_hospitals <- desired_data[desired_rows, 2]
#if there are multiple hospitals with the minimum outcome value, then
#return the first hospital name from the alphabetically sorted hospital
#names list
if (length(desired_hospitals) > 1) {
hospitals_sorted <- sort(desired_hospitals)
hospitals_sorted[1]
}
else {
desired_hospitals
}
})
source("best.R")
best("TX","heart attack")
source("best.R")
best("TX","heart attack")
source("best.R")
best("TX","heart attack")
submit
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
source("rankall.R")
head(rankall("heart attack",20),10)
source("rankhospital.R")
head(rankall("heart attack",20),10)
submit()
submit()
submit()
swirl()
swirl()
help(swirl)
?swirl
library(swirl)
library(swirl)
install.packages(swirl)
library("swirl")
install.packages("swirl")
library(swirl)
swirl()
library("swirl")
swirl()
install.packages("swirl")
install.packages("swirl")
swirl()
install.packages("CRF")
library(CRF)
library("CRF")
install.packages("swirl")
install.packages("swirl", repos="http://cran.rstudio.com/", dependencies=TRUE)
install.packages("swirl")
installed.packages("swirl")
installed.packages("linwood")
pwd
library
library()
install.packages("swirl")
swirl()
library(swirl)
swirl()
library("swirl")
ls
ls()
library(swirl)
swirl()
getwd()
ls()
x <- 9
ls()
list.files()
dir()
?list.files
list.files(args())
args(list.files())
args(list.files)
old.dir <- getwd()
dir.create(testdir)
?dir.create
dir.create(())
dir.create()
dir.create(".")
dir.create("testdir")
setwd("testdir")
file.create("mytest.R")
ls()
list.files()
file.exists("mytest.R")
file.info("mytest.R")
file.rename("mytest.R","mytest2.R")
file.copy("mytest2.R")
file.copy("mytest2.R","mytest3.R")
file.path("mytest3.R")
file.path('folder1','folder2')
?dir.create
dir.create(file.path("testdir2","testdir3"))
dir.create(file.path("testdir2","testdir3")recursive=TRUE)
dir.create(file.path('testdir2','testdir3')recursive=TRUE)
dir.create(file.path('testdir2','testdir3'),recursive=TRUE)
unlink('testdir2',recursive=TRUE)
setwd(old.dir)
unlink('testdir',recursive = TRUE)
